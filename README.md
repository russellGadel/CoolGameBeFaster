# Описание проекта

![](https://github.com/russellGadel/CoolGameBeFaster/blob/Develop/ReadmeAssets/Images/gameImg.jpg)
          
            
##            Детали:  

+	Игра  бесконечная.
+	Этапы прохождения игры привязаны к количеству очков, которые были проспаунены. Определенное количество проспауненных очков привязано к уровню сложности.
+	Каждый уровень сложности уровня конфигурируется.
+	С течением времени  изменяются параметры спаунящихся очков(количество очков появляющихся одномоментно, время жизни, промежуток между спаунами), изменяются параметры объектов наносящих урон(количество объектов появляющихся одномоментно, промежуток между спаунами, тип префаба который будет спаунится).Префаб объекта наносящего урон настраивается – внешний вид, скорость перемещения и т.д.
+	Управление в мобильном проекте – контроллер в нижнем правом углу, PC – WASD. 
+	Настраивается количество попыток прохождения уровня за просмотр рекламы.
+	Места соединения с внешними ресурсами, проверки интернет соединения:             
    + запрос RemoteConig data,
    + UnityAds; 
    
+ Можно добавлять различные карты. Карта выбирается рандомно в начале игры. 
+ Можно добавлять различные объекты наносящие урон. 
            
Имеется 2 сцены: 
1. сцена – загрузочная. 
1. сцена – геймплей + стартовое окно(ввиду небольшого проекта, а так можно было бы вынести в другую сцену). 

## Архитектура:  

### Стек:  
+ Unity 2020.3.32f1, EcsLeo , UniLeo, Zenject, RemoteConfig, UnityAds.
         
### Многоступенчатая система загрузки сцены 

Для асинхронной загрузки сцен применяются корутины. Cистемы отвечающие за загрузку системы разделены по уровням: 
+ BootstrapExecutor – отвечает за последовательность загрузки глобальных блоков. 
+ ICustomInstallersExecutor – отвечает за последовательность загрузки Custom Components;
+ ICustomEventsLoader - отвечает за последовательность загрузки Custom Events;
+ Ecs, Systems – отвечают за последовательность инициализации систем и порядок вызова систем в каждом кадре.

#### Порядок загрузки сцены 
1.Связывание зависимостей в Zenject; 

##### Awake 
           
2.ISceneBootstrapper(загрузчик сцены): 
+ Enter() – действия при входе в сцену; 
    + Добаление загрузчиков в Bootstrap Executor(контролирует порядок загрузки Bootstrappers) 
+ Exit() - действия при выходе с сцены; 
            
3.InstallersBootsrapper(загрузчик Custom компонентов); 
+ Custom компоненты – независимые Services, Views; 

4.EventsBootsrapper(загрузчик Custom Events); 
+ Custom Events – место где взаимодействуют независимые Custom компоненты.
   + Типы: 
     + Event – обычное событие которое имеет однонаправленное выполнение, Execute().
     + DualEvent – событие может быть отменено. Execute(), Undo();
     + Допустим Открыть какое то окно, которое параллельно еще +100500 внешних компонентов  задействует , а потом аккуратно закрыть его обратно, откатив нужные нам внешние компоненты обратно.
           
5. EcsBootstrapper (загрузчик Ecs, в сценах с геймплеем); 
6. Последний Bootstrapper зависит от того, что нужно сделать после загрузки всей системы. Допустим если мы на сцене загрузки, то нужно загрузить сцену Геймплея. Если на сцене Геймплея, то нужно начать игру. 
            
#### Start 
7. Создание префабов в фабриках(модифицировано в следующем проекте [TestProject1](https://github.com/russellGadel/TestProject1) , в котором создание префабов происходит не в Start, а уже является продолжением общей загрузки системы в Awake, т.е. там уже есть возможность выбора последовательности инициализации фабрик); 
   В общем сначала загружаются независимые компоненты(views, services), затем события, где эти компоненты взаимодействуют, в ecs  загружается геймплейная логика. 
            
### Архитектурная конфигурация сцены 
+ CustomComponents подключаются к сцене путем размещения Installers в SceneContext(GameObject), нужно прокинуть связь в MonoInstaller. 
+ CustomEvents подключаются к сцене в SceneEventsInstaller(Script); 

### Архитектурная конфигурация ECS 
#### EcsLeo 
1. Данные(settings), ссылки на Services и CustomEvents, Views пробрасываются через SceneData, SceneServies, SceneViews соотвественно. 
2.	Имеется две системы UpdateSystem, FixedUpdateSystem для разделения физики и обычных систем; 
3.	Имеются следующие типы систем: 
+ IEcsPreInit – аналог Awake – ступень PreInit; 
+ IEcsInit – инициализация после PreInit;
+ IEcsRun – системы выполняющиеся каждый кадр; 
+	IEcsRun OneFrame Events – системы выполняющиеся при необходимости только один раз на одном кадре;

4. Как правило системы в физике выполняются каждый кадр, а обычные системы как OneFrame;
5. Компоненты:  
+	Component – содержат данные; 
+ Tag – просто помечают объект на сцене; 
+	Event – обозначают начало события; 

6.	Триггерные события на сцене передаются в ECS через Triggers, которые добавляют в Entity нужный EventComponent.
7.	Начальные сущности создаются в Init системах в Ecs, фабриках, а так же на сцене с помощью UniLeo. Создание сущности на сцене(нужные gameObjects, prefabs) – добавляется ComponentProvider(представитель Ecs Компонента на сцене Unity) на gameObject. Далее внутри фреймворка UniLeo, на стадии PreInit, осуществляется поиск на сцене gameObjects, содержащих ConvertToEntity компонент(компонент на объекте обозначающий, что его нужно конвертировать в сущность), далее создается сущность на основании добавленных компонентов. В следующем проекте [TestProject1](https://github.com/russellGadel/TestProject1) эта система была переделана, где на базе фреймворка UniLeo я сделал кастомное аналогичное решение,но уже там есть возможность выбора времени инициализации сущности на сцене, что удобно при создании префабов. 
            
### Реализация CustomComponents

1. Installer (MonoInstaller) 
+ Связывание зависимости (Zenject). 
+ Инициализация внутренних модулей, установка внутренних зависимостей между модулями, доставка компоненту Settings с редактора Unity. 
    
2.	Дальнейшие этапы зависят от того, что реализуется: 
+	Services – реализация сервиса. 
+	View - если View имеет какие-то внутренние данные, то реализация в MVP, если это просто View, которое не имеет собственных данных, то реализация как IView(без избыточного Presenter); 
                
В целом в формате MVP обязанности модулей: 
+ Model – данные модуля, их обработка, доступ к данным;
+ View (MonoBehaviour) – ссылки на внешние элементы управления View(кнопки, TuchElements), функции изменения внешнего вида и т.д. 
+ Presenter – связывает View и Model, чаще всего взаимодействие реализуется паттерном Наблюдатель. Предоставляет интерфейс для взаимодействия с компонентом извне.


### Важные Custom компоненты 
         
+ ISaveDataService           
   + void SubscribeToSaveEvent(Action observer); 
   + void UnsubscribeFromSaveEvent(Action observer); 
   + ref SaveData GetData();
            
Слушатели подключаются на этапе загрузки проекта. В момент сохранения, те кому нужно сохраниться подтягиваются автоматически сами. 

+ IInternetConnectionService 
    + void CheckInternetConnection([CanBeNull] Action thenHasInternetConnection, [CanBeNull] Action thenHasNotInternetConnection); 
            
+ ICustomScenesLoader()  
    + void LoadScene(ScenesNaming sceneNaming); 
    + IEnumerator LoadSceneAsync(ScenesNaming sceneNaming, ISceneBootstrapper currentSceneBootstrapper); 
      	        
Все Custom компоненты находятся в директориях Services, CustomUI. 
            
### Тесты производительности  на устройстве Android, Honor 9A.  

+ [Profiler;](https://github.com/russellGadel/CoolGameBeFaster/tree/Develop/ReadmeAssets/ProfilerData)
+ [Memory Profiler.](https://github.com/russellGadel/CoolGameBeFaster/tree/Develop/ReadmeAssets/MemoryProfilerData)
         

